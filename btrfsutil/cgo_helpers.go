// GPL-2

// WARNING: This file has automatically been generated on Sun, 01 Nov 2020 21:26:34 EST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package btrfsutil

/*
#cgo LDFLAGS: -lbtrfsutil
#include <btrfsutil.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *BtrfsQgroupInherit) Ref() *C.struct_btrfs_util_qgroup_inherit {
	if x == nil {
		return nil
	}
	return (*C.struct_btrfs_util_qgroup_inherit)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *BtrfsQgroupInherit) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewBtrfsQgroupInheritRef converts the C object reference into a raw struct reference without wrapping.
func NewBtrfsQgroupInheritRef(ref unsafe.Pointer) *BtrfsQgroupInherit {
	return (*BtrfsQgroupInherit)(ref)
}

// NewBtrfsQgroupInherit allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewBtrfsQgroupInherit() *BtrfsQgroupInherit {
	return (*BtrfsQgroupInherit)(allocStructBtrfsUtilQgroupInheritMemory(1))
}

// allocStructBtrfsUtilQgroupInheritMemory allocates memory for type C.struct_btrfs_util_qgroup_inherit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructBtrfsUtilQgroupInheritMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructBtrfsUtilQgroupInheritValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructBtrfsUtilQgroupInheritValue = unsafe.Sizeof([1]C.struct_btrfs_util_qgroup_inherit{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *BtrfsQgroupInherit) PassRef() *C.struct_btrfs_util_qgroup_inherit {
	if x == nil {
		x = (*BtrfsQgroupInherit)(allocStructBtrfsUtilQgroupInheritMemory(1))
	}
	return (*C.struct_btrfs_util_qgroup_inherit)(unsafe.Pointer(x))
}

// allocStructBtrfsUtilSubvolumeInfoMemory allocates memory for type C.struct_btrfs_util_subvolume_info in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructBtrfsUtilSubvolumeInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructBtrfsUtilSubvolumeInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructBtrfsUtilSubvolumeInfoValue = unsafe.Sizeof([1]C.struct_btrfs_util_subvolume_info{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BtrfsSubvolumeInfo) Ref() *C.struct_btrfs_util_subvolume_info {
	if x == nil {
		return nil
	}
	return x.ref92562e03
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BtrfsSubvolumeInfo) Free() {
	if x != nil && x.allocs92562e03 != nil {
		x.allocs92562e03.(*cgoAllocMap).Free()
		x.ref92562e03 = nil
	}
}

// NewBtrfsSubvolumeInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBtrfsSubvolumeInfoRef(ref unsafe.Pointer) *BtrfsSubvolumeInfo {
	if ref == nil {
		return nil
	}
	obj := new(BtrfsSubvolumeInfo)
	obj.ref92562e03 = (*C.struct_btrfs_util_subvolume_info)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BtrfsSubvolumeInfo) PassRef() (*C.struct_btrfs_util_subvolume_info, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref92562e03 != nil {
		return x.ref92562e03, nil
	}
	mem92562e03 := allocStructBtrfsUtilSubvolumeInfoMemory(1)
	ref92562e03 := (*C.struct_btrfs_util_subvolume_info)(mem92562e03)
	allocs92562e03 := new(cgoAllocMap)
	allocs92562e03.Add(mem92562e03)

	var cid_allocs *cgoAllocMap
	ref92562e03.id, cid_allocs = (C.uint64_t)(x.Id), cgoAllocsUnknown
	allocs92562e03.Borrow(cid_allocs)

	var cparent_id_allocs *cgoAllocMap
	ref92562e03.parent_id, cparent_id_allocs = (C.uint64_t)(x.ParentId), cgoAllocsUnknown
	allocs92562e03.Borrow(cparent_id_allocs)

	var cdir_id_allocs *cgoAllocMap
	ref92562e03.dir_id, cdir_id_allocs = (C.uint64_t)(x.DirId), cgoAllocsUnknown
	allocs92562e03.Borrow(cdir_id_allocs)

	var cflags_allocs *cgoAllocMap
	ref92562e03.flags, cflags_allocs = (C.uint64_t)(x.Flags), cgoAllocsUnknown
	allocs92562e03.Borrow(cflags_allocs)

	var cuuid_allocs *cgoAllocMap
	ref92562e03.uuid, cuuid_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.Uuid)), cgoAllocsUnknown
	allocs92562e03.Borrow(cuuid_allocs)

	var cparent_uuid_allocs *cgoAllocMap
	ref92562e03.parent_uuid, cparent_uuid_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.ParentUuid)), cgoAllocsUnknown
	allocs92562e03.Borrow(cparent_uuid_allocs)

	var creceived_uuid_allocs *cgoAllocMap
	ref92562e03.received_uuid, creceived_uuid_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.ReceivedUuid)), cgoAllocsUnknown
	allocs92562e03.Borrow(creceived_uuid_allocs)

	var cgeneration_allocs *cgoAllocMap
	ref92562e03.generation, cgeneration_allocs = (C.uint64_t)(x.Generation), cgoAllocsUnknown
	allocs92562e03.Borrow(cgeneration_allocs)

	var cctransid_allocs *cgoAllocMap
	ref92562e03.ctransid, cctransid_allocs = (C.uint64_t)(x.Ctransid), cgoAllocsUnknown
	allocs92562e03.Borrow(cctransid_allocs)

	var cotransid_allocs *cgoAllocMap
	ref92562e03.otransid, cotransid_allocs = (C.uint64_t)(x.Otransid), cgoAllocsUnknown
	allocs92562e03.Borrow(cotransid_allocs)

	var cstransid_allocs *cgoAllocMap
	ref92562e03.stransid, cstransid_allocs = (C.uint64_t)(x.Stransid), cgoAllocsUnknown
	allocs92562e03.Borrow(cstransid_allocs)

	var crtransid_allocs *cgoAllocMap
	ref92562e03.rtransid, crtransid_allocs = (C.uint64_t)(x.Rtransid), cgoAllocsUnknown
	allocs92562e03.Borrow(crtransid_allocs)

	x.ref92562e03 = ref92562e03
	x.allocs92562e03 = allocs92562e03
	return ref92562e03, allocs92562e03

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BtrfsSubvolumeInfo) PassValue() (C.struct_btrfs_util_subvolume_info, *cgoAllocMap) {
	if x.ref92562e03 != nil {
		return *x.ref92562e03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BtrfsSubvolumeInfo) Deref() {
	if x.ref92562e03 == nil {
		return
	}
	x.Id = (uint)(x.ref92562e03.id)
	x.ParentId = (uint)(x.ref92562e03.parent_id)
	x.DirId = (uint)(x.ref92562e03.dir_id)
	x.Flags = (uint)(x.ref92562e03.flags)
	x.Uuid = *(*[16]byte)(unsafe.Pointer(&x.ref92562e03.uuid))
	x.ParentUuid = *(*[16]byte)(unsafe.Pointer(&x.ref92562e03.parent_uuid))
	x.ReceivedUuid = *(*[16]byte)(unsafe.Pointer(&x.ref92562e03.received_uuid))
	x.Generation = (uint)(x.ref92562e03.generation)
	x.Ctransid = (uint)(x.ref92562e03.ctransid)
	x.Otransid = (uint)(x.ref92562e03.otransid)
	x.Stransid = (uint)(x.ref92562e03.stransid)
	x.Rtransid = (uint)(x.ref92562e03.rtransid)
}

// Ref returns a reference to C object as it is.
func (x *BtrfsSubvolumeIterator) Ref() *C.struct_btrfs_util_subvolume_iterator {
	if x == nil {
		return nil
	}
	return (*C.struct_btrfs_util_subvolume_iterator)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *BtrfsSubvolumeIterator) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewBtrfsSubvolumeIteratorRef converts the C object reference into a raw struct reference without wrapping.
func NewBtrfsSubvolumeIteratorRef(ref unsafe.Pointer) *BtrfsSubvolumeIterator {
	return (*BtrfsSubvolumeIterator)(ref)
}

// NewBtrfsSubvolumeIterator allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewBtrfsSubvolumeIterator() *BtrfsSubvolumeIterator {
	return (*BtrfsSubvolumeIterator)(allocStructBtrfsUtilSubvolumeIteratorMemory(1))
}

// allocStructBtrfsUtilSubvolumeIteratorMemory allocates memory for type C.struct_btrfs_util_subvolume_iterator in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructBtrfsUtilSubvolumeIteratorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructBtrfsUtilSubvolumeIteratorValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructBtrfsUtilSubvolumeIteratorValue = unsafe.Sizeof([1]C.struct_btrfs_util_subvolume_iterator{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *BtrfsSubvolumeIterator) PassRef() *C.struct_btrfs_util_subvolume_iterator {
	if x == nil {
		x = (*BtrfsSubvolumeIterator)(allocStructBtrfsUtilSubvolumeIteratorMemory(1))
	}
	return (*C.struct_btrfs_util_subvolume_iterator)(unsafe.Pointer(x))
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSSByte transforms a sliced Go data structure into plain C format.
func unpackArgSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.char)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfc4425b.Data = unsafe.Pointer(ptr1)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?
	}
}

// unpackArgSBtrfsSubvolumeInfo transforms a sliced Go data structure into plain C format.
func unpackArgSBtrfsSubvolumeInfo(x []BtrfsSubvolumeInfo) (unpacked *C.struct_btrfs_util_subvolume_info, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStructBtrfsUtilSubvolumeInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_btrfs_util_subvolume_info)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_btrfs_util_subvolume_info)(h.Data)
	return
}

// packSBtrfsSubvolumeInfo reads sliced Go data structure out from plain C format.
func packSBtrfsSubvolumeInfo(v []BtrfsSubvolumeInfo, ptr0 *C.struct_btrfs_util_subvolume_info) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructBtrfsUtilSubvolumeInfoValue]C.struct_btrfs_util_subvolume_info)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBtrfsSubvolumeInfoRef(unsafe.Pointer(&ptr1))
	}
}

// allocPStructBtrfsUtilSubvolumeIteratorMemory allocates memory for type *C.struct_btrfs_util_subvolume_iterator in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructBtrfsUtilSubvolumeIteratorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructBtrfsUtilSubvolumeIteratorValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPStructBtrfsUtilSubvolumeIteratorValue = unsafe.Sizeof([1]*C.struct_btrfs_util_subvolume_iterator{})

// unpackArgSSBtrfsSubvolumeIterator transforms a sliced Go data structure into plain C format.
func unpackArgSSBtrfsSubvolumeIterator(x [][]BtrfsSubvolumeIterator) (unpacked **C.struct_btrfs_util_subvolume_iterator, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPStructBtrfsUtilSubvolumeIteratorMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_btrfs_util_subvolume_iterator)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.struct_btrfs_util_subvolume_iterator)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_btrfs_util_subvolume_iterator)(h.Data)
	return
}

// packSSBtrfsSubvolumeIterator reads sliced Go data structure out from plain C format.
func packSSBtrfsSubvolumeIterator(v [][]BtrfsSubvolumeIterator, ptr0 **C.struct_btrfs_util_subvolume_iterator) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_btrfs_util_subvolume_iterator)(unsafe.Pointer(ptr0)))[i0]
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxff2234b.Data = unsafe.Pointer(ptr1)
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?
	}
}

// allocPUint64TMemory allocates memory for type *C.uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUint64TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPUint64TValue = unsafe.Sizeof([1]*C.uint64_t{})

// unpackArgSSUUint transforms a sliced Go data structure into plain C format.
func unpackArgSSUUint(x [][]uint) (unpacked **C.uint64_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPUint64TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uint64_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uint64_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uint64_t)(h.Data)
	return
}

// packSSUUint reads sliced Go data structure out from plain C format.
func packSSUUint(v [][]uint, ptr0 **C.uint64_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uint64_t)(unsafe.Pointer(ptr0)))[i0]
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf0d18b7.Data = unsafe.Pointer(ptr1)
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?
	}
}

// allocPStructBtrfsUtilQgroupInheritMemory allocates memory for type *C.struct_btrfs_util_qgroup_inherit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructBtrfsUtilQgroupInheritMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructBtrfsUtilQgroupInheritValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPStructBtrfsUtilQgroupInheritValue = unsafe.Sizeof([1]*C.struct_btrfs_util_qgroup_inherit{})

// unpackArgSSBtrfsQgroupInherit transforms a sliced Go data structure into plain C format.
func unpackArgSSBtrfsQgroupInherit(x [][]BtrfsQgroupInherit) (unpacked **C.struct_btrfs_util_qgroup_inherit, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPStructBtrfsUtilQgroupInheritMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_btrfs_util_qgroup_inherit)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.struct_btrfs_util_qgroup_inherit)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_btrfs_util_qgroup_inherit)(h.Data)
	return
}

// packSSBtrfsQgroupInherit reads sliced Go data structure out from plain C format.
func packSSBtrfsQgroupInherit(v [][]BtrfsQgroupInherit, ptr0 **C.struct_btrfs_util_qgroup_inherit) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_btrfs_util_qgroup_inherit)(unsafe.Pointer(ptr0)))[i0]
		hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf69fe70.Data = unsafe.Pointer(ptr1)
		hxf69fe70.Cap = 0x7fffffff
		// hxf69fe70.Len = ?
	}
}
